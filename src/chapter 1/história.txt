O ano é 2051 e você está no ramo de restaurantes. A automação, em grande parte por trabalhadores robóticos, impulsiona a maior parte da economia, mas acontece que os humanos ainda gostam de sair para comer de vez em quando. Em seu restaurante, todos os funcionários são robôs-humanóides, é claro, mas inconfundivelmente robôs. O fabricante de robôs de maior sucesso é a Threading Inc., e os trabalhadores robôs dessa empresa passaram a ser chamados de "ThreadBots".

Exceto por esse pequeno detalhe robótico, seu restaurante parece e funciona como um daqueles estabelecimentos antigos de, digamos, 2020. Seus convidados estarão procurando por aquela experiência vintage. Eles querem comida fresca preparada do zero. Eles querem sentar-se à mesa. Eles querem esperar pelas refeições - mas só um pouco. Eles querem pagar no final, e às vezes até deixam uma gorjeta, pelos velhos tempos.

Sendo novo no negócio de restaurantes robóticos, você faz o que qualquer outro restaurante faz e contrata uma pequena frota de robôs: um para receber os clientes na recepção (GreetBot), um para servir à mesa e anotar pedidos (WaitBot), um para cozinhar (ChefBot) e um para gerenciar o bar (WineBot).

Clientes famintos chegam na recepção e são recebidos por GreetBot, o ThreadBot da frente da casa. Eles são então direcionados a uma mesa e, uma vez sentados, WaitBot leva seu pedido. Então WaitBot traz essa ordem para a cozinha em um pedaço de papel (porque você quer preservar aquela experiência antiga, lembra?). ChefBot olha o pedido na papeleta e começa a preparar a comida. WaitBot irá verificar periodicamente se a comida está pronta e, quando estiver, irá imediatamente levar os pratos para a mesa dos clientes. Quando os convidados estão prontos para sair, eles retornam ao GreetBot, que calcula a conta, recebe o pagamento e, graciosamente, deseja-lhes uma noite agradável.

Seu restaurante é um sucesso e você logo crescerá e terá uma grande base de clientes. Seus funcionários robôs fazem exatamente o que lhes é dito e são perfeitamente bons nas tarefas que você atribui a eles. Tudo está indo muito bem e você não poderia estar mais feliz.

Com o tempo, entretanto, você começa a notar alguns problemas. Oh, não é nada verdadeiramente sério; apenas algumas coisas que parecem dar errado. Todos os outros proprietários de restaurantes robóticos parecem ter pequenas falhas semelhantes. É um pouco preocupante que esses problemas pareçam piorar à medida que você se torna mais bem-sucedido.

Embora raros, existem as colisões ocasionais que são muito perturbadoras: às vezes, quando um prato de comida está pronto na cozinha, WaitBot o agarra antes mesmo de ChefBot largar o prato. Isso geralmente termina com a quebra do prato e deixa uma grande bagunça. ChefBot limpa tudo, é claro, mas ainda assim, você pensaria que esses robôs de primeira linha saberiam ser um pouco mais sincronizados uns com os outros. Isso também acontece no bar: às vezes, o WineBot faz um pedido de bebida no bar e o WaitBot o pega antes que o WineBot o solte, resultando em vidros quebrados e Nederburg Cabernet Sauvignon derramado.

Além disso, às vezes o GreetBot acomoda novos clientes exatamente no mesmo momento em que Wait-Bot decidiu limpar o que pensava ser uma mesa vazia. É muito estranho para os clientes. Você tentou adicionar lógica de atraso à função de limpeza do WaitBot ou atrasos à função de assento do GreetBot, mas isso não ajuda muito, e as colisões ainda ocorrem. Mas pelo menos esses eventos são raros.

Bem, eles costumavam ser. Seu restaurante se tornou tão popular que você teve que contratar mais alguns ThreadBots. Para noites de sexta e sábado muito ocupadas, você teve que adicionar um segundo GreetBot e dois WaitBots extras. Infelizmente, os contratos de prestação de serviços para ThreadBots determina que você tem que contratá-los para a semana inteira, então isso efetivamente significa que na maior parte da parte tranquila da semana, você está carregando três Thread ‐ Bots extras que você realmente não precisa.

O outro problema de recursos, além do custo extra, é que dá mais trabalho para você lidar com esses ThreadBots extras. Era bom manter o controle sobre apenas quatro bots, mas agora você tem sete. Manter o controle de sete ThreadBots dá muito mais trabalho e, como seu restaurante fica cada vez mais famoso, você fica preocupado em aceitar ainda mais ThreadBots. Vai se tornar um trabalho de tempo integral apenas para acompanhar o que cada ThreadBot está fazendo. E outra coisa: esses Thread ‐ Bots extras estão usando muito mais espaço dentro do seu restaurante. Está se tornando um aperto para seus clientes, com todos esses robôs circulando. Você está preocupado porque, se precisar adicionar ainda mais bots, esse problema de espaço ficará ainda pior. Você deseja usar o espaço em seu restaurante para clientes, não para ThreadBots.

As colisões também pioraram desde que você adicionou mais ThreadBots. Agora, às vezes dois WaitBots tomam exatamente a mesma ordem da mesma mesa ao mesmo tempo. É como se os dois notassem que a mesa estava pronta para o pedido e se movessem para pegá-la, sem perceber que o outro WaitBot estava fazendo exatamente a mesma coisa. Como você pode imaginar, isso resulta em pedidos de comida duplicados, o que causa carga extra na cozinha e aumenta a chance de colisões ao pegar os pratos prontos. Você está preocupado pois se adicionar mais WaitBots então o problema pode piorar.

O tempo passa.

Então, durante um serviço noturno de sexta-feira , muito movimentado, você tem um momento singular de clareza: o tempo passa, a lucidez o oprime e você vê um instante de seu restaurante congelado no tempo. Meus ThreadBots estão fazendo nada! Na verdade não é nada, para ser justo, mas eles estão apenas ... esperando.

Cada um dos três WaitBots em mesas diferentes está esperando por um dos clientes em sua mesa para fazer o pedido. O WineBot já preparou 17 drinks, que agora aguardam coleta (demorou apenas alguns segundos), e aguarda novo pedido de bebida. Um dos GreetBots cumprimentou um novo grupo de convidados e disse-lhes que precisavam esperar um minuto para se sentarem e que está aguardando a resposta dos convidados. O outro GreetBot, agora processando um pagamento com cartão de crédito para outro cliente que está saindo, está aguardando confirmação no dispositivo de gateway de pagamento. Até o ChefBot, que atualmente está cozinhando 35 refeições, não está realmente fazendo nada neste momento, mas está apenas esperando que uma das refeições termine de cozinhar para que possa ser montado num prato e entregue a um WaitBot.

Você percebe que, embora seu restaurante agora esteja cheio de ThreadBots, e você esteja considerando comprar mais (com todos os problemas que isso acarreta), os que você tem atualmente não estão sendo totalmente utilizados.

O momento passa, mas não a realização. No domingo, você adiciona um módulo de coleta de dados aos ThreadBots. Para cada ThreadBot, você está medindo quanto tempo é gasto esperando e quanto tempo é gasto ativamente no trabalho. Ao longo da semana seguinte, os dados são coletados. Então, no domingo à noite, você analisa os resultados. Acontece que mesmo quando seu restaurante está com capacidade total, o ThreadBot mais trabalhador fica ocioso cerca de 98% do tempo. Os ThreadBots são tão eficientes que podem realizar qualquer tarefa em frações de segundo.

Como empresário, essa ineficiência realmente o incomoda. Você sabe que todos os outros proprietários de restaurantes robóticos estão administrando seus negócios da mesma forma que você, com muitos dos mesmos problemas. Mas você pensa, batendo com o punho na mesa: "Deve haver uma maneira melhor!"

Então, no dia seguinte, que é uma segunda-feira tranquila, você tenta algo ousado: você programa um único ThreadBot para fazer todas as tarefas. Cada vez que começa a esperar, mesmo que por um segundo, o ThreadBot passa para a próxima tarefa a ser feita no restaurante, seja ela qual for, ao invés de esperar. Parece incrível, apenas um ThreadBot fazendo o trabalho de todos os outros, mas você tem certeza de que seus cálculos estão corretos. Além disso, segunda-feira é um dia tranquilo; mesmo se algo der errado, o impacto será pequeno. Para este novo projeto, você chama o bot de “LoopBot” porque ele fará um loop em todos os trabalhos do restaurante.

A programação estava mais difícil do que o normal. Não é só que você teve que programar um ThreadBot com todas as tarefas diferentes; você também teve que programar parte da lógica de quando alternar entre as tarefas. Mas, neste estágio, você já teve muita experiência com a programação desses ThreadBots, então você consegue fazer isso.

Você enxerga seu LoopBot como um falcão. Ele se move entre as estações em frações de segundo, verificando se há trabalho a ser feito. Pouco depois da abertura, o primeiro convidado chega à recepção. O LoopBot aparece quase imediatamente e pergunta se o convidado gostaria de uma mesa perto da janela ou perto do bar. Mas então, quando o LoopBot começa a esperar, sua programação diz para ele passar para a próxima tarefa e ele apaga. Isso parece um erro terrível, mas então você vê que, quando o convidado começa a dizer “Janela, por favor”, o LoopBot está de volta. Ele recebe a resposta e direciona o convidado para a mesa 42. E lá se vai de novo, verificando se há pedidos de bebida, comida, toalha de mesa e convidados chegando, uma e outra vez.

No final da noite de segunda-feira, você se parabeniza por um sucesso notável. Você verifica o módulo de coleta de dados no LoopBot, e ele confirma que mesmo com um único ThreadBot fazendo o trabalho de sete, o tempo ocioso ainda estava em torno de 97%. Este resultado dá a você a confiança necessária para continuar a experiência durante o resto da semana.

À medida que o serviço de sexta-feira se aproxima, você reflete sobre o grande sucesso de sua experiência. Para manutenção durante uma semana normal de trabalho, você pode gerenciar facilmente a carga de trabalho com um único LoopBot. E você notou outra coisa: você não vê mais nenhuma colisão. Isso faz sentido; como há apenas um LoopBot, ele não pode ser confundido com ele mesmo. Não há mais pedidos duplicados indo para a cozinha e não há mais confusão sobre quando pegar um prato ou uma bebida.

Então, infelizmente, algo deu errado: uma das refeições, um suflê intrincado, fracassou. Isso nunca aconteceu antes em seu restaurante. Você começa a estudar o LoopBot mais de perto. Acontece que em uma de suas mesas há um visitante muito tagarela. Este cliente veio ao seu restaurante sozinho e continua tentando conversar com o LoopBot, às vezes até segurando seu LoopBot pela mão. Quando isso acontece, o LoopBot não consegue sair correndo e atender à lista cada vez maior de tarefas em outros lugares do restaurante. É por isso que a cozinha produziu seu primeiro suflê fracassado: seu LoopBot não conseguiu voltar para a cozinha para tirar a farinha do forno porque foi segurado por um cliente.

A sexta-feira termina e você volta para casa para refletir sobre o que aprendeu. É verdade que o LoopBot foi capaz de fazer todo o trabalho que era necessário no movimentado serviço do dia; mas, por outro lado, sua cozinha produziu sua primeira refeição estragada, algo que nunca aconteceu antes. Convidados tagarelas costumavam manter os WaitBots ocupados o tempo todo, mas isso nunca afetou o serviço da cozinha.

Levando tudo em consideração, você decide que ainda é melhor continuar usando um único LoopBot. Essas colisões preocupantes não ocorrem mais e há muito mais espaço em seu restaurante - espaço que você pode usar para mais clientes. Mas você percebe algo profundo sobre o LoopBot: ele pode ser eficaz apenas se todas as tarefas forem curtas, ou pelo menos puder ser executado em um curto período de tempo. Se alguma atividade mantiver o LoopBot ocupado por muito tempo então outras tarefas começarão a sofrer negligência.

É difícil saber com antecedência quais tarefas podem levar muito tempo. E se um convidado pedir um coquetel que exige uma preparação complicada, levando muito mais tempo do que o normal? E se um cliente quiser reclamar de uma refeição na recepção, recusar-se a pagar e agarrar o LoopBot pelo braço, impedindo-o de trocar de tarefa? Você decide que, em vez de resolver todos esses problemas com antecedência, é melhor continuar com o LoopBot, registrar o máximo de informações possível e lidar com quaisquer problemas posteriormente, conforme eles surgirem.

Mais tempo passa.

Gradualmente, outros proprietários de restaurantes notam sua operação e, eventualmente, descobrem que eles também podem sobreviver, e até mesmo prosperar, com apenas um único ThreadBot. A notícia se espalha. Logo, todos os restaurantes funcionam dessa maneira, e fica difícil lembrar que restaurantes robóticos já operaram com vários ThreadBots.


Epílogo:
Em nossa história, cada robô trabalhador do restaurante é uma única thread. A observação chave na história é que a natureza do trabalho no restaurante envolve uma grande quantidade de espera, assim como requests.get () está esperando por uma resposta de um servidor.

Em um restaurante, o tempo de espera do trabalhador não é enorme quando humanos lentos estão fazendo o trabalho manual, mas quando robôs super eficientes e rápidos estão fazendo o trabalho, quase todo o tempo é gasto esperando. Na programação de computadores, o mesmo é verdadeiro quando a programação de rede está envolvida. CPUs funcionam e aguardam a E/S da rede. As CPUs dos computadores modernos são extremamente rápidas - centenas de milhares de vezes mais rápidas do que o tráfego da rede. Portanto, CPUs que executam programas de rede gastam muito tempo esperando.

O insight da história é que os programas podem ser escritos para direcionar explicitamente o trabalho da CPU entre as tarefas conforme o necessário. Embora haja uma melhoria na economia (usando menos CPUs para o mesmo trabalho), a vantagem real, em comparação com uma abordagem de threading (multi-CPU), é a eliminação das condições de corrida. 

No entanto, nem tudo são rosas: como descobrimos na história, há vantagens e desvantagens na maioria das soluções de tecnologia. A introdução do LoopBot resolveu uma certa classe de problemas, mas também introduziu novos problemas - o menos importante deles é que o proprietário do restaurante teve que aprender uma forma ligeiramente diferente de programação.
